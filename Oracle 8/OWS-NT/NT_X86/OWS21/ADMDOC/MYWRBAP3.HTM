<HTML>
<HEAD>
<TITLE>
The MyWRBApp Sample Cartridge
</TITLE>
</HEAD>
 
<BODY BGCOLOR="FFFFFF">
 
<A HREF="mywrbapp.htm"><IMG SRC="up.jpg" ALIGN=MIDDLE ALT="Top"></A>
<A HREF="mywrbap2.htm"><IMG SRC="previous.jpg" ALIGN=MIDDLE ALT="Previous"></A>
<A HREF="contents.htm"><IMG SRC="toc.jpg" ALIGN=MIDDLE ALT="TOC"></A>
<A HREF="owshtmli.htm"><IMG SRC="index.jpg" ALIGN=MIDDLE ALT="Index"></A>
<BR>
<IMG SRC="h2omark.gif">
<BR>

<H1>
<A NAME="422331">
mywrbapp.c
</A>
</H1>
<HR SIZE=5>
<A NAME="422332">
<PRE>#include "mywrbapp.h"<br> <br>#ifdef DEBUG<br>static char debug[1024];<br>#endif<br> <br>/*<br> * forward declarations<br> */<br>WRBReturnCode newUser(myappctx *ctx, void *WRBCtx);<br> <br>WRBReturnCode getUserData(myappctx *ctx, void *WRBCtx);<br> <br>WRBReturnCode editUserData(myappctx *ctx, void *WRBCtx);<br> <br>WRBReturnCode getCatalog(myappctx *ctx, void *WRBCtx);<br> <br>WRBReturnCode placeOrder(myappctx *ctx, void *WRBCtx);<br> <br>WRBReturnCode confirmOrder(myappctx *ctx, void *WRBCtx);<br> <br>WRBReturnCode addUser(const datablock* newdata, myappctx* ctx,<br>  void *WRBCtx);<br> <br>WRBReturnCode rehash(const char *oldname, const datablock* newdata,<br>  myappctx* ctx, void *WRBCtx);<br> <br>WRBReturnCode formatUserData(const datablock *data, myappctx *ctx,<br>  void *WRBCtx);<br> <br>void userDataError(const char *message, const char *URL, myappctx *ctx,<br>  void *WRBCtx);<br> <br>WRBReturnCode storeInfo(const char* user, myappctx *ctx, void *WRBCtx);<br> <br>datablock *getDataBlock(const char *user, myappctx *ctx, void *WRBCtx);<br> <br>WRBReturnCode formatOrder(const boolean invoice, myappctx *ctx,<br>  void *WRBCtx);<br> <br>boolean taxable(char *user, myappctx *ctx, void *WRBCtx);<br> <br>int itemcmp(const void* item1, const void* item2);<br> <br>myappctx *mapdata(const int fd, myappctx *ctx, void *WRBCtx);<br> <br>WRBReturnCode remapdata(myappctx *ctx, void *WRBCtx);<br> <br>WRBReturnCode growdata(myappctx *ctx, void *WRBCtx);<br></PRE><P>
</A>
<HR>
<H2>
<A NAME="422334">
MyWRBApp_Entry()
</A>
</H2>
<A NAME="422335">
<code>MyWRBApp_Entry()</code> sets up the provided WRBCallbacks dispatch table so the WRB application engine can call MyWRBApp's cartridge functions.<P>
</A><A NAME="422336">
<PRE>WRBReturnCode<br>MyWRBApp_Entry(WRBCallbacks *WRBCalls)<br>{<br>    WRBCalls-&gt;init_WRBCallback = MyWRBApp_Init;<br>    WRBCalls-&gt;authorize_WRBCallback = MyWRBApp_Authorize;<br>    WRBCalls-&gt;exec_WRBCallback = MyWRBApp_Exec;<br>    WRBCalls-&gt;shut_WRBCallback = MyWRBApp_Shutdown;<br>    WRBCalls-&gt;reload_WRBCallback = MyWRBApp_Reload;<br>    /* Version and Version_Free currently not implemented */<br> <br>    return (WRB_DONE);<br>}<br></PRE><P>
</A>
<HR>
<H2>
<A NAME="422338">
MyWRBApp_Init()
</A>
</H2>
<A NAME="422339">
<code>MyWBApp_Init()</code> sets up the cartridge to handle client requests. It opens the data file and calls the <code><a href="mywrbap3.htm#422506">mapdata()</a></code> function to map the data file into memory and allocate the application context structure. <code>MyWRBApp_Init()</code> then completes initialization of the context structure and passes it back to the WRB application engine when it returns.<P>
</A><A NAME="422343">
<PRE>WRBReturnCode<br>MyWRBApp_Init(void *WRBCtx, void **appCtx)<br>{<br>    int fd;<br>    myappctx *ctx;<br>    char datafile[256];<br>    char *ohome;<br> <br>    ohome = WRBGetORACLE_HOME(WRBCtx);<br>    sprintf(datafile, "%s/ows21/sample/wrbsdk/mywrbapp/datafile", ohome);<br>    fd = open(datafile, O_CREAT | O_RDWR, 0664);<br>    if (fd == -1) {<br>        /* bad news--can't get to datafile--shut down app */<br>#ifdef DEBUG<br>        sprintf(debug, "MyWRBApp_Init: failed to open datafile: %s",<br>          strerror(errno));<br>        WRBLogMessage(WRBCtx, debug, 1);<br>#endif<br>        return (WRB_ABORT);<br>    }<br> <br>    /* map datafile into memory */<br>    if (!(ctx = mapdata(fd, NULL, WRBCtx))) {<br>        return (WRB_ABORT);<br>    }<br> <br>    /* allocate order items array */<br>    ctx-&gt;items = (orderitem *)malloc((MAXITEMS + 1) * sizeof(orderitem));<br>    ctx-&gt;numitems = 0;<br> <br>    /* load configuration parameters */<br>    MyWRBApp_Reload(WRBCtx, ctx);<br> <br>#ifdef DEBUG<br>    sprintf(debug, "MyWRBApp_Init: context structure fields are:");<br>    WRBLogMessage(WRBCtx, debug, 1);<br>    sprintf(debug, "table: %X\nfirstfree: %X\ndatacount: %X\ndatablocks: %X",<br>      ctx-&gt;table, ctx-&gt;firstfree, ctx-&gt;datacount, ctx-&gt;datablocks);<br>    WRBLogMessage(WRBCtx, debug, 1);<br>    sprintf(debug, "datafd: %d\nend: %u\nitems: %X\nnumitems: %d",<br>      ctx-&gt;datafd, ctx-&gt;end, ctx-&gt;items, ctx-&gt;numitems);<br>    WRBLogMessage(WRBCtx, debug, 1);<br>#endif<br> <br>    /* pass back context pointer to WRB application engine */<br>    *appCtx = ctx;<br> <br>    return (WRB_DONE);<br>}<br></PRE><P>
</A>
<HR>
<H2>
<A NAME="422346">
MyWRBApp_Shutdown()
</A>
</H2>
<A NAME="422347">
<code>MyWRBApp_Shutdown()</code> frees resources used by the cartridge in preparation for termination. It saves the data file to the file system, and unmaps and closes the data file. It then frees the ordered items array and the application context structure before returning.<P>
</A><A NAME="422348">
<PRE>WRBReturnCode<br>MyWRBApp_Shutdown(void *WRBCtx, void *appCtx)<br>{<br>    myappctx *ctx = (myappctx *)appCtx;<br> <br>    WRLOCK(FILE_START, FILE_SIZE, ctx)<br> <br>    /* sync data file */<br>    msync((char *)ctx-&gt;table, ctx-&gt;end, MS_SYNC | MS_INVALIDATE);<br> <br>    UNLOCK(ctx)<br> <br>    /* unmap and close data file */<br>    munmap((char *)ctx-&gt;table, ctx-&gt;end);<br>    close(ctx-&gt;datafd);<br> <br>    /* free items array and context structure */<br>    free(ctx-&gt;items);<br>    free(ctx);<br> <br>    return (WRB_DONE);<br>}<br></PRE><P>
</A>
<HR>
<H2>
<A NAME="422350">
MyWRBApp_Authorize()
</A>
</H2>
<A NAME="422351">
The WRB application engine calls <code>MyWRBApp_Authorize()</code> when it receives a request directed to MyWRBApp. <code>MyWRBApp_Authorize()</code> authenticates the client issuing the request.<P>
</A><A NAME="422352">
MyWRBApp doesn't require any special authorization to register a new a username, so if the request is "newuser," <code>MyWRBApp_Authorize()</code> grants authorization and returns immediately.<P>
</A><A NAME="422353">
Otherwise, <code>MyWRBApp_Authorize()</code> uses the WRB API function <code>WRBSetAuthorization()</code> to set up a new basic authentication realm named "MyWRBApp" with the client. This tells the client browser to prompt the user for a username and password and cache them. The browser will then provide this username/password pair when the Web Listener asks for authentication data for this realm in the future.<P>
</A><A NAME="422354">
<code>MyWRBApp_Authorize()</code> calls the WRB API function <code>WRBGetUserID()</code> to get the username that the user entered in the client browser's authentication dialog. If <code>WRBGetUserID()</code> returns NULL, it's probably because the client browser is issuing its first request to MyWRBApp, so the MyWRBApp authentication realm was not established before the client issued the request. This isn't an error--MyWRBApp just denies authorization and returns normally. The client browser responds by prompting the user for a username and password using the MyWRBApp realm, and retries the request. Next time, the call to <code>WRBGetUserID()</code> will succeed.<P>
</A><A NAME="422355">
<PRE>WRBReturnCode<br>MyWRBApp_Authorize(void *WRBCtx, void *appCtx, boolean *bAuthorized)<br>{<br>    char *URL, *req, *user, *password;<br>    datablock *data;<br>    myappctx *ctx = (myappctx *)appCtx;<br>    int cmp;<br> <br>    /* get request URL */<br>    URL = WRBGetURL(WRBCtx);<br>    URL = strdup(URL);      /* copy to local memory */<br>#ifdef DEBUG<br>    sprintf(debug, "MyWRBApp_Authorize: Request URL is: %s", URL);<br>    WRBLogMessage(WRBCtx, debug, 1);<br>#endif<br> <br>    /* last path element defines request name */<br>    req = strrchr(URL, `/');<br>    req++;<br>    if (!strncmp(req, "newuser", 7)) {<br>        /* client is creating a new account, and is therefore authorized */<br>        *bAuthorized = TRUE;<br>        return (WRB_DONE);<br>    }<br> <br>    /*<br>     * set up a new basic authentication realm called "MyWRBApp"<br>     * and share it with the client<br>     */<br>    WRBSetAuthorization(WRBCtx, WRB_AUTH_BASIC_NEW, "MyWRBApp", FALSE);<br> <br>    /* get the username provided by the client */<br>    user = WRBGetUserID(WRBCtx);<br>    if (!user) {<br>        /*<br>         * This is probably the client's first call to this app--<br>         * Just return normally with authorization failed<br>         */<br>        *bAuthorized = FALSE;<br>#ifdef DEBUG<br>        sprintf(debug,<br>          "MyWRBApp_Authorize: WRBGetUserID failed");<br>        WRBLogMessage(WRBCtx, debug, 1);<br>#endif<br>        return (WRB_DONE);<br>    }<br> <br>    /* copy username to local memory */<br>    user = strdup(user);<br> <br>    /* get data block for this user */<br>    data = getDataBlock(user, ctx, WRBCtx);<br>    if (!data) {<br>        /* unknown user - not authorized */<br>        *bAuthorized = FALSE;<br>#ifdef DEBUG<br>        sprintf(debug, "MyWRBApp_Authorize: unknown user %s not authorized",<br>          user);<br>        WRBLogMessage(WRBCtx, debug, 1);<br>#endif<br>        return(WRB_DONE);<br>    }<br> <br>    /* get the password provided by the client and copy to local memory */<br>    password = WRBGetPassword(WRBCtx);<br>    password = strdup(password);<br> <br>    RDLOCK(DBLOCK_OFF(data, ctx), sizeof(datablock), ctx)<br> <br>    /* compare stored password with password given */<br>    cmp = strcmp(password, /* XXX decrypt(*/data-&gt;password/*)*/);<br> <br>    UNLOCK(ctx)<br> <br>    if (!cmp) {<br>        *bAuthorized = TRUE;<br>    }<br>    else {<br>        *bAuthorized = FALSE;<br>#ifdef DEBUG<br>        sprintf(debug,<br>          "MyWRBApp_Authorize: user %s gave an incorrect password: %s",<br>          user, password);<br>        WRBLogMessage(WRBCtx, debug, 1);<br>#endif<br>    }<br> <br>    return(WRB_DONE);<br>}<br></PRE><P>
</A>
<HR>
<H2>
<A NAME="422360">
MyWRBApp_Exec()
</A>
</H2>
<A NAME="422361">
The WRB application engine calls <code>MyWRBApp_Exec()</code> to handle a request when <code>MyWRBApp_Authorize()</code> has indicated that the client is authorized. <code>MyWRBApp_Exec()</code> reads the URL to determine the request. MyWRBApp supports the following requests:<P>
</A><ul type=disc><A NAME="422362">
<LI>newuser--register a new username
</A>
<A NAME="422363">
<LI>getuserdata--display to the client the currently authenticated user's registration data
</A>
<A NAME="422364">
<LI>edituserdata--apply the user's changes to his or her registration data
</A>
<A NAME="422365">
<LI>getcatalog--display the product catalog to the client
</A>
<A NAME="422366">
<LI>placeorder--display to the client a summary of the items the currently authenticated user has ordered, asking the user to confirm the order
</A>
<A NAME="422367">
<LI>confirm--display to the client an invoice for a confirmed order, including total price
</A>
<A NAME="422368">
<PRE>WRBReturnCode<br>MyWRBApp_Exec(void *WRBCtx, void *appCtx)<br>{<br>    char *URL, *req;<br>    myappctx *ctx = (myappctx *)appCtx;<br> <br>    /* get request URL */<br>    URL = WRBGetURL(WRBCtx);<br>    URL = strdup(URL);<br> <br>    /* last path element defines request name */<br>    req = strrchr(URL, '/');<br>    req++;<br> <br>#ifdef DEBUG<br>    sprintf(debug, "MyWRBApp_Exec: request is %s", req);<br>    WRBLogMessage(WRBCtx, debug, 1);<br>#endif<br> <br>    if (!strncmp(req, "newuser", 7)) {<br>        return (newUser(ctx, WRBCtx));<br>    }<br>    else if (!strncmp(req, "getuserdata", 11)) {<br>        return (getUserData(ctx, WRBCtx));<br>    }<br>    else if (!strncmp(req, "edituserdata", 12)) {<br>        return (editUserData(ctx, WRBCtx));<br>    }<br>    else if (!strncmp(req, "getcatalog", 10)) {<br>        return(getCatalog(ctx, WRBCtx));<br>    }<br>    else if (!strncmp(req, "placeorder", 10)) {<br>        return(placeOrder(ctx, WRBCtx));<br>    }<br>    else if (!strncmp(req, "confirm", 7)) {<br>        return(confirmOrder(ctx, WRBCtx));<br>    }<br> <br>    /* bad URL--send HTTP error */<br>    WRBReturnHTTPError(WRBCtx, (WRBErrorCode)400, NULL, TRUE);<br> <br>    return(WRB_DONE);<br>}<br></PRE><P>
</A>
</ul><HR>
<H2>
<A NAME="422372">
MyWRBApp_Reload()
</A>
</H2>
<A NAME="422376">
<code>MyWRBApp_Reload()</code> uses the WRB API function <code><a href="wrbapi7.htm#425517">WRBGetConfigVal()</a></code> to update the application context structure's copies of the cartridge's configurable parameters.<P>
</A><A NAME="422377">
<PRE>WRBReturnCode<br>MyWRBApp_Reload(void* WRBCtx, void *appCtx)<br>{<br>    myappctx *ctx = (myappctx*)appCtx;<br>    char *tax;<br>    char *cp;<br> <br>    /* get configuration parameters */<br>    ctx-&gt;state = WRBGetConfigVal(WRBCtx, "state");<br>    tax = WRBGetConfigVal(WRBCtx, "tax");<br> <br>    if (tax) {<br>        /* remove percent sign from tax, if any */<br>        cp = strchr(tax, `%');<br>        if (cp) {<br>            cp = `\0';<br>        }<br>        ctx-&gt;taxpct = atof(tax);<br>    }<br>    else {<br>        ctx-&gt;taxpct = (double)0;<br>    }<br> <br>    return (WRB_DONE);<br>}<br></PRE><P>
</A>
<HR>
<H2>
<A NAME="422380">
newUser()
</A>
</H2>
<A NAME="422381">
<code>MyWRBApp_Exec()</code> calls <code>newUser()</code> to handle "newuser" requests. Its primary task is to process the data from the newuser.html form that the client has submitted (see the $ORACLE_HOME/ows21/sample/wrbsdk/mywrbapp directory on your WebServer machine).<P>
</A><A NAME="422382">
<code>newUser()</code> uses WRB API function <code>WRBGetParsedContent()</code> to parse the CGI data from the form. <code>WRBGetParsedContent()</code> passes back an array of WRBEntry structures, each of which encodes the name and value of an input field on the form. <code>newUser()</code> then uses the WRB API function <code>WRBGetNamedEntry()</code> to extract the values of specific input fields.<P>
</A><A NAME="422383">
<PRE>WRBReturnCode<br>newUser(myappctx *ctx, void *WRBCtx)<br>{<br>    char *user, *password, *confirm, *cp;<br>    boolean confirmed;<br>    datablock newdata;<br>    WRBReturnCode ret;<br>    WRBEntry *entries;<br>    int numentries;<br>    char wbuf[1024];<br>    int len;<br> <br>    /* get username from form data */<br>    WRBGetParsedContent(WRBCtx, &amp;entries, &amp;numentries);<br>    user = WRBGetNamedEntry("username", entries, numentries);<br> <br>    /* check whether this name is in use */<br>    if (getDataBlock(user, ctx, WRBCtx)) {<br>        /*<br>         * The given username is already in use--<br>         * respond with an error page<br>         */<br>        userDataError("The username you entered is already registered to another user. Please choose another username.",<br>          "/sample/wrbsdk/mywrbapp/newuser.html", ctx, WRBCtx);<br> <br>        return (WRB_DONE);<br>    }<br> <br>    /* start filling in newdata */<br>    strcpy(newdata.username, user);<br> <br>    /* get password from form data */<br>    password = WRBGetNamedEntry("password", entries, numentries);<br> <br>    /* get password confirmation and compare with password */<br>    confirm = WRBGetNamedEntry("confirm", entries, numentries);<br>    if (!strcmp(password, confirm)) {<br>        /* password and confirmation string match--fill in password */<br>        confirmed = TRUE;<br>        strcpy(newdata.password, password);     /* XXX encrypt? */<br>    }<br>    else {<br>        /* they don't match--null out password for now */<br>        confirmed = FALSE;<br>        newdata.password[0] = `\0';<br>    }<br> <br>    /* add this user to the datafile */<br>    ret = addUser(&amp;newdata, ctx, WRBCtx);<br>    if (ret != WRB_DONE) {<br>        return (ret);<br>    }<br> <br>    ret = storeInfo(user, ctx, WRBCtx);<br>    if (ret != WRB_DONE) {<br>        return (ret);<br>    }<br> <br>    if (!confirmed) {<br>        /*<br>         * confirmation doesn't match password--generate error page<br>         */<br>        userDataError("The password you entered does not match your confirmation string. Please reenter your password",<br>          "/mywrbapp/bin/getuserdata", ctx, WRBCtx);<br> <br>        return (WRB_DONE);<br>    }<br> <br>    /* done--go to catalog */<br>    return (getCatalog(ctx, WRBCtx));<br>}<br></PRE><P>
</A>
<HR>
<H2>
<A NAME="422385">
getUserData()
</A>
</H2>
<A NAME="422386">
<code>MyWRBApp_Exec()</code> calls <code>getUserData()</code> to handle "getuserdata" requests. Its task is to extract from the data file the username and password of the currently authenticated user, and call <code><a href="mywrbap3.htm#422452">formatUserData()</a></code> to generate and send to the client an HTML form containing the user's registration data. <code>getUserData()</code> uses the WRB API function <code>WRBGetUserID()</code> to identify the currently authenticated user.<P>
</A><A NAME="422390">
<PRE>WRBReturnCode<br>getUserData(myappctx *ctx, void *WRBCtx)<br>{<br>    char *user;<br>    datablock *data;<br>    WRBReturnCode ret;<br> <br>    /* get name of currently authenticated user */<br>    user = WRBGetUserID(WRBCtx);<br>    user = strdup(user);<br>    if (!user) {<br>        /* this shouldn't happen--Authorize has already been called */<br>        return (WRB_ERROR);<br>    }<br> <br>    /* get datablock for this user */<br>    data = getDataBlock(user, ctx, WRBCtx);<br>    if (!data) {<br>        /*<br>         * this shouldn't happen--if the user is authenticated, there<br>         * should be a datablock<br>         */<br>        return (WRB_ERROR);<br>    }<br> <br>    RDLOCK(DBLOCK_OFF(data, ctx), sizeof(datablock), ctx)<br> <br>    /* fill in HTML form template and write it to the client */<br>    ret = formatUserData(data, ctx, WRBCtx);<br> <br>    UNLOCK(ctx)<br> <br>    return (ret);<br>}<br></PRE><P>
</A>
<HR>
<H2>
<A NAME="422393">
editUserData()
</A>
</H2>
<A NAME="422397">
When the user edits and submits the HTML form generated by <code><a href="mywrbap3.htm#422385">getUserData()</a></code>, the form's action specifies the "edituserdata" request. <code>MyWRBApp_Exec()</code> then calls <code>editUserData()</code> to handle this request.<P>
</A><A NAME="422401">
Like <code><a href="mywrbap3.htm#422380">newUser()</a></code>, <code>editUserData()</code> uses the WRB API functions <code>WRBGetParsedContent()</code> and <code>WRBGetNamedEntry()</code> to parse the CGI data from the form.<P>
</A><A NAME="422402">
<PRE>WRBReturnCode<br>editUserData(myappctx *ctx, void *WRBCtx)<br>{<br>    char *user, *password, *confirm;<br>    boolean confirmed, nameInUse = FALSE;<br>    char wbuf[1024];<br>    int len;<br>    datablock newdata;<br>    datablock *data;<br>    WRBEntry *entries;<br>    int numentries;<br> <br>    /* get data from form */<br>    WRBGetParsedContent(WRBCtx, &amp;entries, &amp;numentries);<br>    user = WRBGetNamedEntry("username", entries, numentries);<br>    password = WRBGetNamedEntry("password", entries, numentries);<br> <br>    /* get password confirmation and compare with password */<br>    confirm = WRBGetNamedEntry("confirm", entries, numentries);<br>    if (!strcmp(password, confirm)) {<br>        /* password and confirmation string match */<br>        confirmed = TRUE;<br>    }<br>    else {<br>        confirmed = FALSE;<br>    }<br> <br>    /* look up currently authenticated user */<br>    data = getDataBlock(WRBGetUserID(WRBCtx), ctx, WRBCtx);<br> <br>    /*<br>     * has the user changed his/her username?<br>     * if so, and the new name is not in use, rehash datablock<br>     */<br> <br>    RDLOCK(DBLOCK_OFF(data, ctx), sizeof(datablock), ctx)<br> <br>    if (strcmp(user, data-&gt;username)) {<br>        /* new usernamee */<br>        if (!getDataBlock(user, ctx, WRBCtx)) {<br>            /* new username not in use--copy it to newdata */<br>            nameInUse = FALSE;<br>            strcpy(newdata.username, user);<br>        }<br>        else {<br>            /* new name is not in use--leave username unchanged */<br>            nameInUse = TRUE;<br>            strcpy(newdata.username, data-&gt;username);<br>        }<br> <br>#ifdef DEBUG<br>        sprintf(debug, "editUserData: old username: %s\n\tnew username %s",<br>          data-&gt;username, user);<br>        WRBLogMessage(WRBCtx, debug, 1);<br>#endif<br> <br>        if (confirmed) {<br>            strcpy(newdata.password, password);     /* XXX encrypt? */<br>        }<br>        else {<br>            /* confirmation failed--leave password unchanged */<br>            strcpy(newdata.password, data-&gt;password);<br>        }<br> <br>        if (rehash(data-&gt;username, &amp;newdata, ctx, WRBCtx) != WRB_DONE) {<br>            UNLOCK(ctx)<br> <br>            return (WRB_ERROR);<br>        }<br>    }<br>    else {<br>        UPGRADE(ctx)<br> <br>        /* change password only if confirmation matched password */<br>        if (confirmed) {<br>            strcpy(data-&gt;password, password);       /* XXX encrypt? */<br>        }<br> <br>        /* sync datafile */<br>        msync((char *)ctx-&gt;table, ctx-&gt;end, MS_SYNC | MS_INVALIDATE);<br> <br>        DOWNGRADE(ctx)<br>    }<br> <br>    /* store the rest of the form data */<br>    storeInfo(data-&gt;username, ctx, WRBCtx);<br> <br>    UNLOCK(ctx)<br> <br>    if (nameInUse) {<br>        /* specified username is already in use--generate error page */<br>        userDataError("The username you entered is already registered to another user. Please choose another username.",<br>          "/mywrbapp/bin/getuserdata", ctx, WRBCtx);<br> <br>        return (WRB_DONE);<br>    }<br> <br>    if (!confirmed) {<br>        /* confirmation doesn't match password--generate error page */<br>        userDataError("The password you entered does not match your confirmation string. Please reenter your password",<br>          "/mywrbapp/bin/getuserdata", ctx, WRBCtx);<br> <br>        return (WRB_DONE);<br>    }<br> <br>    /* done--go to catalog */<br>    return(getCatalog(ctx, WRBCtx));<br>}<br></PRE><P>
</A>
<HR>
<H2>
<A NAME="422404">
getCatalog()
</A>
</H2>
<A NAME="422405">
<code>MyWRBApp_Exec()</code> calls <code>getCatalog()</code> to handle "getcatalog" requests. It's main task is to read the catalog file (catalog.txt), apply HTML formatting to it, and send it to the client as an editable HTML form.<P>
</A><A NAME="422406">
To show any pending order data associated with the client, <code>getCatalog()</code> calls <code><a href="wrbapi10.htm#425649">WRBGetEnvironmentVariable()</a></code> to extract the client's cookie data from the Web Listener environment. For each catalog item, <code>getCatalog()</code> then searches the cookie string for that item's part number; if it finds the item in the cookie, it uses its value to set the default value of the input field in the output form. This value represents the quantity of the item ordered.<P>
</A><A NAME="422410">
<PRE>WRBReturnCode<br>getCatalog(myappctx *ctx, void *WRBCtx)<br>{<br>    FILE *cat;<br>    char buf[1024];<br>    char wbuf[1024];<br>    int len;<br>    char *cp, *tp;<br>    char part[PARTNUMLEN + 1];<br>    char qty[5] = "\0";<br>    char *qp;<br>    char catfile[256];<br>    char *ohome;<br> <br>    /* open catalog */<br>    ohome = WRBGetORACLE_HOME(WRBCtx);<br>    sprintf(catfile, "%s/ows21/sample/wrbsdk/mywrbapp/catalog.txt", ohome);<br>    cat = fopen(catfile, "r");<br>    if (!cat) {<br>#ifdef DEBUG<br>        sprintf(debug, "getCatalog: failed to open catalog: %s",<br>          strerror(errno));<br>        WRBLogMessage(WRBCtx, debug, 1);<br>#endif<br>        return (WRB_ABORT);<br>    }<br> <br>    /* start generating HTML for the client */<br>    WRBClientWrite(WRBCtx, "Content-type: text/html\n\n", 25);<br> <br>    len = sprintf(wbuf,<br>      "&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;Hot Goods Catalog&lt;/TITLE&gt;&lt;/HEAD&gt;\n");<br>    WRBClientWrite(WRBCtx, wbuf, len);<br> <br>    len = sprintf(wbuf, "&lt;BODY BGCOLOR=\"FFFFFF\"&gt;\n");<br>    WRBClientWrite(WRBCtx, wbuf, len);<br> <br>    len = sprintf(wbuf, "&lt;H1&gt;Hot Goods Catalog&lt;/H1&gt;\n");<br>    WRBClientWrite(WRBCtx, wbuf, len);<br> <br>    len = sprintf(wbuf,<br>      "&lt;FORM ACTION=\"/mywrbapp/bin/placeorder\" METHOD=\"POST\"&gt;\n");<br>    WRBClientWrite(WRBCtx, wbuf, len);<br> <br>    /* get cookie from the client */<br>    cp = WRBGetEnvironmentVariable(WRBCtx, "HTTP_COOKIE");<br>#ifdef DEBUG<br>    if (!cp) {<br>        WRBLogMessage(WRBCtx, "getCatalog: no cookie found", 0);<br>    }<br>#endif<br> <br>    /*<br>     * Loop through the catalog generating HTML for each line--<br>     * for each part number listed in the catalog, check the<br>     * cookie to see if the user has already entered an order quantity<br>     * for the item<br>     */<br>    while (fgets(buf, 1024, cat)) {<br>        /* write the description line to the client */<br>        WRBClientWrite(WRBCtx, "&lt;P&gt;", 3);<br>        WRBClientWrite(WRBCtx, buf, strlen(buf));<br>        WRBClientWrite(WRBCtx, "&lt;/P&gt;\n&lt;P&gt;", 8);<br> <br>        /* get part number line and write it out without the newline */<br>        fgets(buf, 1024, cat);<br>        WRBClientWrite(WRBCtx, buf, strlen(buf) - 1);<br> <br>        /* the part number is the first PARTNUMLEN chars of buf */<br>        strncpy(part, buf, PARTNUMLEN);<br>        part[PARTNUMLEN] = `\0';<br> <br>        if (tp = cp) {<br>            /* search through cookie for part number */<br>            qp = qty;<br>            while (tp) {<br>                if (!strncmp(tp, part, PARTNUMLEN)) {<br>                    /* found part number--now get quantity */<br>                    tp = strchr(tp, `=');<br>                    tp++;<br>                    while (*tp &amp;&amp; (*tp != `;')) {<br>                        *qp++ = *tp++;<br>                    }<br>                    break;<br>                }<br>                tp = strchr(tp, `;');<br>                if (tp) {<br>                    tp += 2;<br>                }<br>            }<br>            *qp = `\0';<br>        }<br> <br>        /*<br>         * complete the HTML line with an input box and set its value to<br>         * the quantity stored in the cookie (if any)<br>         */<br>        len = sprintf(wbuf,<br>          " Order quantity: &lt;INPUT TYPE=\"text\" NAME=\"%s\" ", part);<br>        WRBClientWrite(WRBCtx, wbuf, len);<br> <br>        len = sprintf(wbuf, "SIZE=\"4\" VALUE=\"%s\"&gt;&lt;/P&gt;\n", qty);<br>        WRBClientWrite(WRBCtx, wbuf, len);<br>    }<br> <br>    /* finish HTML page */<br>    len = sprintf(wbuf, "&lt;INPUT TYPE=\"submit\" NAME=\"submit\" ");<br>    WRBClientWrite(WRBCtx, wbuf, len);<br> <br>    len = sprintf(wbuf, "VALUE=\"Place Order\"&gt;\n");<br>    WRBClientWrite(WRBCtx, wbuf, len);<br> <br>    len = sprintf(wbuf, "&lt;/FORM&gt;\n&lt;/BODY&gt;\n&lt;/HTML&gt;");<br>    WRBClientWrite(WRBCtx, wbuf, len);<br> <br>    fclose(cat);<br>    return (WRB_DONE);<br>}<br></PRE><P>
</A>
<HR>
<H2>
<A NAME="422413">
placeOrder()
</A>
</H2>
<A NAME="422417">
When the user edits and submits the HTML form generated by <code><a href="mywrbap3.htm#422404">getCatalog()</a></code>, the form's action specifies the "placeorder" request. <code>MyWRBApp_Exec()</code> then calls <code>placeOrder()</code> to handle this request. Its main task is to generate an HTML form that summarizes the items the client has ordered, and asking the client for confirmation.<P>
</A><A NAME="422418">
To determine the items ordered, <code>placeOrder()</code> first parses the cookie data, and then the data from the form generated by <code><a href="mywrbap3.htm#422404">getCatalog()</a></code>. In the case of a discrepancy between the cookie data and form data, <code>placeOrder()</code> uses the form data. This allows a user to change the quantity on an order item or delete an item from the order entirely before submitting the "placeorder" request.<P>
</A><A NAME="422422">
<PRE>WRBReturnCode<br>placeOrder(myappctx *ctx, void *WRBCtx)<br>{<br>    WRBReturnCode ret;<br>    WRBEntry *entries;<br>    int numentries, item, ent;<br>    char wbuf[1024];<br>    int len;<br>    char *cp, *tp;<br>    char *qp;<br>    orderitem *items;<br> <br>    item = 0;<br>    items = ctx-&gt;items;<br> <br>    /* get cookie from the client */<br>    cp = WRBGetEnvironmentVariable(WRBCtx, "HTTP_COOKIE");<br>    if (cp) {<br>        /* put cookie name-value pairs into items array */<br>        tp = cp;<br>        while (item &lt; MAXITEMS) {<br>            /*<br>             * include only names that start with a part number<br>             */<br>            if (isdigit(*tp)) {<br>                strncpy(items[item].partnum, tp, PARTNUMLEN);<br>                items[item].partnum[PARTNUMLEN] = `\0';<br> <br>                /* the value is the order quantity */<br>                tp = strchr(tp, `=');<br>                tp++;<br>                qp = items[item].qty;<br>                while (*tp &amp;&amp; (*tp != `;')) {<br>                    *qp++ = *tp++;<br>                }<br>                *qp = `\0';<br>                item++;<br>            }<br>            else {<br>                /* not a numeric name--skip this name-value pair */<br>                tp = strchr(tp, `;');<br>            }<br>            if (!tp || (*tp == `\0')) {<br>                /* reached the end of the cookie */<br>                break;<br>            }<br>            tp += 2;<br>        }<br>    }<br>#ifdef DEBUG<br>    else {<br>        WRBLogMessage(WRBCtx, "placeOrder: no cookie found", 0);<br>    }<br>#endif<br> <br>    /* save number of items found in cookie */<br>    ctx-&gt;numitems = item;<br>#ifdef DEBUG<br>    sprintf(debug, "placeOrder: numitems: %d", ctx-&gt;numitems);<br>    WRBLogMessage(WRBCtx, debug, 1);<br>#endif<br> <br>    /* get form data */<br>    WRBGetParsedContent(WRBCtx, &amp;entries, &amp;numentries);<br>    for (ent = 0; ent &lt; numentries; ent++) {<br>        /*<br>         * for each name-value pair from the form, search through<br>         * part numbers found in the cookie for a duplicate--<br>         * if found, replace the cookie data with the form data<br>         */<br>        for (item = 0; item &lt; ctx-&gt;numitems; item++) {<br>            if (!strcmp(entries[ent].name, items[item].partnum)) {<br>                /* found a duplicate */<br>                strcpy(items[item].partnum, entries[ent].name);<br>                strcpy(items[item].qty, entries[ent].value);<br>                entries[ent].name[0] = `\0';<br>                entries[ent].value[0] = `\0';<br>                break;<br>            }<br>        }<br>    }<br> <br>    /* transfer any remaining form data to items array */<br>    item = ctx-&gt;numitems; /* take up where we left off */<br>    for (ent = 0; (ent &lt; numentries) &amp;&amp; (item &lt; MAXITEMS); ent++) {<br>        if (isdigit(entries[ent].name[0]) &amp;&amp; entries[ent].value[0] &amp;&amp;<br>          strcmp(entries[ent].value, "0")) {<br>            /* the name is a part number with a non-zero value (quantity) */<br>            strcpy(items[item].partnum, entries[ent].name);<br>            strcpy(items[item].qty, entries[ent].value);<br>            item ++;<br>        }<br>    }<br>    ctx-&gt;numitems = item;<br> <br>#ifdef DEBUG<br>    sprintf(debug, "placeOrder: numitems: %d", ctx-&gt;numitems);<br>    WRBLogMessage(WRBCtx, debug, 1);<br>#endif<br> <br>    /* sort items array */<br>    qsort(items, ctx-&gt;numitems, sizeof(orderitem), itemcmp);<br> <br>    /* begin writing response page */<br>    WRBClientWrite(WRBCtx, "Content-type: text/html\n", 24);<br>    item = 0;<br> <br>    /* write cookie data */<br>    while (item &lt; ctx-&gt;numitems) {<br>        if (items[item].qty[0] &amp;&amp; strcmp(items[item].qty, "0")) {<br>            /* item has non-zero quantity--put it in the cookie */<br>            len = sprintf(wbuf, "Set-Cookie: %s=%s; path=/\n",<br>              items[item].partnum, items[item].qty);<br>            WRBClientWrite(WRBCtx, wbuf, len);<br>        }<br>        else {<br>            /*<br>             * the item has a zero quantity--delete it from the cookie<br>             * by setting past expiration date<br>             */<br>            len = sprintf(wbuf,<br>              "Set-Cookie: %s=0; path=/; ", items[item].partnum);<br>            WRBClientWrite(WRBCtx, wbuf, len);<br> <br>            len = sprintf(wbuf,<br>              "expires=Monday, 01-Jan-96 00:00:00 GMT\n");<br>            WRBClientWrite(WRBCtx, wbuf, len);<br>        }<br>        item++;<br>    }<br> <br>    /* remember the empty line before "&lt;HTML&gt;" */<br>    WRBClientWrite(WRBCtx, "\n", 1);<br> <br>    if (item &gt;= MAXITEMS) {<br>        /* XXX orders array maxed out--write warning message */<br>    }<br> <br>    len = sprintf(wbuf, "&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;Order Form&lt;/TITLE&gt;&lt;/HEAD&gt;\n");<br>    WRBClientWrite(WRBCtx, wbuf, len);<br> <br>    len = sprintf(wbuf, "&lt;BODY BGCOLOR=\"FFFFFF\"&gt;\n");<br>    WRBClientWrite(WRBCtx, wbuf, len);<br> <br>    len = sprintf(wbuf, "&lt;H1&gt;Placing an Order&lt;/H1&gt;\n");<br>    WRBClientWrite(WRBCtx, wbuf, len);<br> <br>    len = sprintf(wbuf,<br>      "&lt;P&gt;These are the items and the quantities you have selected. ");<br>    WRBClientWrite(WRBCtx, wbuf, len);<br> <br>    len = sprintf(wbuf,<br>      "To change the quantity of an item you want to order, ");<br>    WRBClientWrite(WRBCtx, wbuf, len);<br> <br>    len = sprintf(wbuf,<br>      "just change the value in the quantity box for that item. ");<br>    WRBClientWrite(WRBCtx, wbuf, len);<br> <br>    len = sprintf(wbuf,<br>      "If you decide you don't want to order an item after all, ");<br>    WRBClientWrite(WRBCtx, wbuf, len);<br> <br>    len = sprintf(wbuf,<br>      "just delete the contents of the item's quantity box. ");<br>    WRBClientWrite(WRBCtx, wbuf, len);<br> <br>    len = sprintf(wbuf,<br>      "To add more items to your order, you can ");<br>    WRBClientWrite(WRBCtx, wbuf, len);<br> <br>    len = sprintf(wbuf,<br>      "&lt;A HREF=\"/mywrbapp/bin/getcatalog\"&gt;return to the catalog&lt;/A&gt;.&lt;/P&gt;\n");<br>    WRBClientWrite(WRBCtx, wbuf, len);<br> <br>    len = sprintf(wbuf, "&lt;FORM ACTION=\"/mywrbapp/bin/confirm\"&gt;\n");<br>    WRBClientWrite(WRBCtx, wbuf, len);<br> <br>    /* write out the ordered items */<br>    ret = formatOrder(FALSE, ctx, WRBCtx);<br>    if (ret != WRB_DONE) {<br>        return (WRB_ERROR);<br>    }<br> <br>    len = sprintf(wbuf, "&lt;INPUT TYPE=\"submit\" VALUE=\"Confirm Order\"&gt;\n");<br>    WRBClientWrite(WRBCtx, wbuf, len);<br> <br>    len = sprintf(wbuf, "&lt;/FORM&gt;\n&lt;/BODY&gt;\n&lt;/HTML&gt;\n");<br>    WRBClientWrite(WRBCtx, wbuf, len);<br> <br>    return (WRB_DONE);<br>}<br></PRE><P>
</A>
<HR>
<H2>
<A NAME="422424">
confirmOrder()
</A>
</H2>
<A NAME="422428">
When the user edits and submits the HTML form generated by <code><a href="mywrbap3.htm#422413">placeOrder()</a></code>, the form's action specifies the "confirm" request. <code>MyWRBApp_Exec()</code> then calls <code>confirmOrder()</code> to handle this request. Its main task is to generate an invoice summarizing the client's order. It also signals the client browser to delete the cookies associated with the order.<P>
</A><A NAME="422435">
Like <code><a href="mywrbap3.htm#422404">getCatalog()</a></code>, <code>confirmOrder()</code> calls <code><a href="wrbapi10.htm#425649">WRBGetEnvironmentVariable()</a></code> to extract the cookie data associated with the client from the Web Listener environment.<P>
</A><A NAME="422436">
<PRE>WRBReturnCode<br>confirmOrder(myappctx *ctx, void *WRBCtx)<br>{<br>    WRBReturnCode ret;<br>    WRBEntry *entries;<br>    int numentries, item, ent;<br>    char wbuf[1024];<br>    int len;<br>    char *cp, *tp;<br>    char part[PARTNUMLEN + 1];<br>    orderitem *items;<br> <br>    /* begin response */<br>    WRBClientWrite(WRBCtx, "Content-type: text/html\n", 24);<br> <br>    /* get cookie from the client */<br>    cp = WRBGetEnvironmentVariable(WRBCtx, "HTTP_COOKIE");<br>    if (cp) {<br>        /*<br>         * the order is now placed--delete cookie entries by setting<br>         * past expiration date<br>         */<br>        tp = cp;<br>        while (tp &amp;&amp; *tp) {<br>            if (isdigit(*tp)) {<br>                /* this name-value pair is an order item--delete it */<br>                strncpy(part, tp, PARTNUMLEN);<br>                part[PARTNUMLEN] = `\0';<br> <br>                len = sprintf(wbuf, "Set-Cookie: %s=0; path=/; ", part);<br>                WRBClientWrite(WRBCtx, wbuf, len);<br> <br>                len = sprintf(wbuf, "expires=Monday, 01-Jan-96 00:00:00 GMT\n");<br>                WRBClientWrite(WRBCtx, wbuf, len);<br>            }<br> <br>            /* find the next name-value pair */<br>            tp = strchr(tp, `;');<br>            if (!tp) {<br>                /* reached the end of the cookie */<br>                break;<br>            }<br>            tp += 2;<br>        }<br>    }<br> <br>    /* remember the blank line */<br>    WRBClientWrite(WRBCtx, "\n", 1);<br> <br>    len = sprintf(wbuf, "&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;Thank You&lt;/TITLE&gt;&lt;/HEAD&gt;\n");<br>    WRBClientWrite(WRBCtx, wbuf, len);<br>    len = sprintf(wbuf, "&lt;BODY BGCOLOR=\"FFFFFF\"&gt;\n");<br>    WRBClientWrite(WRBCtx, wbuf, len);<br>    len = sprintf(wbuf, "&lt;H1&gt;Thank you for your order&lt;/H1&gt;\n");<br>    WRBClientWrite(WRBCtx, wbuf, len);<br>    len = sprintf(wbuf,<br>      "&lt;P&gt;These are the items and the quantities you have ordered.&lt;/P&gt;\n");<br>    WRBClientWrite(WRBCtx, wbuf, len);<br> <br>    /* get form data and fill in ordered items array */<br>    WRBGetParsedContent(WRBCtx, &amp;entries, &amp;numentries);<br>    items = ctx-&gt;items;<br>    item = 0;<br>    for (ent = 0; (ent &lt; numentries) &amp;&amp; (item &lt; MAXITEMS); ent++) {<br>        if (isdigit(entries[ent].name[0]) &amp;&amp; entries[ent].value[0]) {<br>            strcpy(items[item].partnum, entries[ent].name);<br>            strcpy(items[item].qty, entries[ent].value);<br>            item ++;<br>        }<br>    }<br>    ctx-&gt;numitems = item;<br> <br>    /* write out the order summary and total by setting invoice to TRUE */<br>    ret = formatOrder(TRUE, ctx, WRBCtx);<br>    if (ret != WRB_DONE) {<br>        return (WRB_ERROR);<br>    }<br> <br>    len = sprintf(wbuf,<br>      "&lt;P&gt;&lt;A HREF=\"/mywrbapp/bin/getcatalog\"&gt;Return to the catalog");<br>    WRBClientWrite(WRBCtx, wbuf, len);<br> <br>    len = sprintf(wbuf, "&lt;/A&gt;.&lt;/P&gt;\n&lt;/BODY&gt;\n&lt;/HTML&gt;\n");<br>    WRBClientWrite(WRBCtx, wbuf, len);<br> <br>    return (WRB_DONE);<br>}<br></PRE><P>
</A>
<HR>
<H2>
<A NAME="422438">
addUser()
</A>
</H2>
<A NAME="422442">
<code><a href="mywrbap3.htm#422380">newUser()</a></code> calls <code>addUser()</code> to allocate a new data block in the data file for the user specified in the data block pointed to by <code>newdata</code>.<P>
</A><A NAME="422443">
<PRE>WRBReturnCode<br>addUser(const datablock* newdata, myappctx* ctx, void *WRBCtx)<br>{<br>    unsigned hashval, idx;<br>    char *cp;<br>    datablock *data;<br> <br>    WRLOCK(FILE_START, FILE_SIZE, ctx)<br> <br>    if (*(ctx-&gt;firstfree)) {<br>        /* there's an unused datablock--take it off the free list */<br>        idx = *(ctx-&gt;firstfree);<br>        data = ctx-&gt;datablocks + idx;<br>        *(ctx-&gt;firstfree) = data-&gt;nextidx;<br>#ifdef DEBUG<br>        sprintf(debug, "addUser: taking block of free list, index %u", idx);<br>        WRBLogMessage(WRBCtx, debug, 1);<br>        sprintf(debug, "firstfree is now %u", *(ctx-&gt;firstfree));<br>        WRBLogMessage(WRBCtx, debug, 1);<br>#endif<br>    }<br>    else {<br>        /*<br>         * add a new datablock to the end of the datablocks array--<br>         * pre-inc datacount to assure no datablock has index 0--<br>         * index 0 means "end of linked list"<br>         */<br>        (*(ctx-&gt;datacount))++;<br> <br>        if (DATABLOCKS_OFF + (*(ctx-&gt;datacount) * sizeof(datablock))<br>          &gt; ctx-&gt;end) {<br>            /* datafile is full--extend it */<br> <br>            UNLOCK(ctx)<br> <br>            if (growdata(ctx, WRBCtx) != WRB_DONE) {<br>                return (WRB_ABORT);<br>            }<br> <br>            WRLOCK(FILE_START, FILE_SIZE, ctx)<br>        }<br> <br>        /*<br>         * calculate address of the new datablock by adding the<br>         * new datacount to the base address of the array<br>         */<br>        idx = *(ctx-&gt;datacount);<br>        data = ctx-&gt;datablocks + idx;<br>#ifdef DEBUG<br>        sprintf(debug, "addUser: adding new datablock for %s, index %u",<br>          newdata-&gt;username, idx);<br>        WRBLogMessage(WRBCtx, debug, 1);<br>#endif<br>    }<br> <br>    /* fill in the new datablock from the data passed in */<br>    strcpy(data-&gt;username, newdata-&gt;username);<br>    strcpy(data-&gt;password, newdata-&gt;password);<br> <br>    /* hash on username--add new datablock to hash table */<br>    cp = data-&gt;username;<br>    THASH(hashval, cp)<br>#ifdef DEBUG<br>    sprintf(debug, "addUser: hashval for %s is %d", data-&gt;username, hashval);<br>    WRBLogMessage(WRBCtx, debug, 1);<br>#endif<br>    data-&gt;nextidx = ctx-&gt;table[hashval];<br>    ctx-&gt;table[hashval] = idx;<br>#ifdef DEBUG<br>    sprintf(debug, "addUser: putting new datablock for %s in bin %d",<br>      data-&gt;username, hashval);<br>    WRBLogMessage(WRBCtx, debug, 1);<br>#endif<br> <br>    /* sync datafile */<br>    msync((char *)ctx-&gt;table, ctx-&gt;end, MS_SYNC | MS_INVALIDATE);<br> <br>    UNLOCK(ctx)<br> <br>    return (WRB_DONE);<br>}<br></PRE><P>
</A>
<HR>
<H2>
<A NAME="422445">
rehash()
</A>
</H2>
<A NAME="422449">
<code><a href="mywrbap3.htm#422393">editUserData()</a></code> calls <code>rehash()</code> when a user changes his or her username. (Because data blocks are hashed by username, a change of username requires the data block to be rehashed and placed in a different hash bin.)<P>
</A><A NAME="422450">
<PRE>WRBReturnCode rehash(const char *oldname, const datablock* newdata,<br>  myappctx* ctx, void *WRBCtx)<br>{<br>    unsigned idx, hashval;<br>    datablock *data, *lastdata;<br>    char *cp;<br>    off_t size;<br> <br>    WRLOCK(FILE_START, FILE_SIZE, ctx)<br> <br>    /*<br>     * check to see if another WRBX has extended the datafile--<br>     * if so, remap the file<br>     */<br>    size = lseek(ctx-&gt;datafd, 0, SEEK_END);<br>    if (size &gt; ctx-&gt;end) {<br>        /* file has grown--remap it */<br> <br>        UNLOCK(ctx)<br> <br>        if (remapdata(ctx, WRBCtx) != WRB_DONE) {<br>            return (WRB_ABORT);<br>        }<br> <br>        WRLOCK(FILE_START, FILE_SIZE, ctx)<br>    }<br> <br>    /* hash on oldname--retrieve datablock from hash table */<br>    cp = strdup(oldname);<br>    THASH(hashval, cp)<br>    lastdata = NULL;<br>    idx = ctx-&gt;table[hashval];<br>    data = ctx-&gt;datablocks + idx;<br>    while (data != ctx-&gt;datablocks) {<br>        /*<br>         * end of list not yet reached--compare datablock username<br>         * with oldname--break out if match<br>         */<br>        if (!strcmp(oldname, data-&gt;username)) {<br>            break;<br>        }<br> <br>        lastdata = data;<br>        idx = data-&gt;nextidx;<br>        data = ctx-&gt;datablocks + idx;<br>    }<br> <br>    if (data == ctx-&gt;datablocks) {<br>        /* end of hash list reached--no datablock found for given username */<br>        return (WRB_ERROR);<br>    }<br> <br>    /* unlink data block */<br>    if (lastdata) {<br>        lastdata-&gt;nextidx = data-&gt;nextidx;<br>    }<br>    else {<br>        ctx-&gt;table[hashval] = data-&gt;nextidx;<br>    }<br> <br>    /* copy new data into datablock */<br>    strcpy(data-&gt;username, newdata-&gt;username);<br>    strcpy(data-&gt;password, newdata-&gt;password);<br> <br>    /* hash on username--relocate datablock in hash table */<br>    cp = data-&gt;username;<br>    THASH(hashval, cp)<br>#ifdef DEBUG<br>    sprintf(debug, "rehash: hashval for %s is %d", data-&gt;username, hashval);<br>    WRBLogMessage(WRBCtx, debug, 1);<br>#endif<br>    data-&gt;nextidx = ctx-&gt;table[hashval];<br>    ctx-&gt;table[hashval] = idx;<br>#ifdef DEBUG<br>    sprintf(debug, "rehash: putting new datablock for %s in bin %d",<br>      data-&gt;username, hashval);<br>    WRBLogMessage(WRBCtx, debug, 1);<br>#endif<br> <br>    /* sync datafile */<br>    msync((char *)ctx-&gt;table, ctx-&gt;end, MS_SYNC | MS_INVALIDATE);<br> <br>    UNLOCK(ctx)<br> <br>    return (WRB_DONE);<br>}<br></PRE><P>
</A>
<HR>
<H2>
<A NAME="422452">
formatUserData()
</A>
</H2>
<A NAME="422456">
<code><a href="mywrbap3.htm#422385">getUserData()</a></code> calls <code>formatUserData()</code> to generate and send to the client an HTML form containing the registration data for the user specified by the data block <code>data</code>.<P>
</A><A NAME="422457">
<PRE>WRBReturnCode<br>formatUserData(const datablock *data, myappctx *ctx, void *WRBCtx)<br>{<br>    char buf[1024];<br>    char wbuf[1024];<br>    char *bp, *ep;<br>    FILE *info;<br>    int len;<br>    char infofile[256];<br>    char *ohome;<br> <br>    /*<br>     * write out data form<br>     */<br>#ifdef DEBUG<br>    WRBLogMessage(WRBCtx, "formatUserData: starting client writes", 0);<br>#endif<br> <br>    WRBClientWrite(WRBCtx, "Content-type: text/html\n\n", 25);<br> <br>    len = sprintf(wbuf,<br>      "&lt;HTML&gt;\n&lt;HEAD&gt;&lt;TITLE&gt;Registration Form&lt;/TITLE&gt;&lt;/HEAD&gt;\n");<br>    WRBClientWrite(WRBCtx, wbuf, len);<br> <br>    len = sprintf(wbuf, "&lt;BODY BGCOLOR=\"FFFFFF\"&gt;\n");<br>    WRBClientWrite(WRBCtx, wbuf, len);<br> <br>    len = sprintf(wbuf,<br>      "&lt;FORM ACTION=\"/mywrbapp/bin/edituserdata\" METHOD=\"POST\"&gt;\n");<br>    WRBClientWrite(WRBCtx, wbuf, len);<br> <br>    /* username */<br>    len = sprintf(wbuf, "&lt;P&gt;Username: &lt;INPUT TYPE=\"text\" NAME=\"username\" ");<br>    WRBClientWrite(WRBCtx, wbuf, len);<br> <br>    len = sprintf(wbuf, "VALUE=\"%s\" MAXLENGTH=\"10\" SIZE=\"10\"&gt;&lt;/P&gt;\n",<br>      data-&gt;username);<br>    WRBClientWrite(WRBCtx, wbuf, len);<br> <br>    /* password */<br>    len = sprintf(wbuf,<br>      "&lt;P&gt;Password: &lt;INPUT TYPE=\"password\" NAME=\"password\" ");<br>    WRBClientWrite(WRBCtx, wbuf, len);<br> <br>    len = sprintf(wbuf, "VALUE=\"%s\" MAXLENGTH=\"10\" SIZE=\"10\"&gt;\n",<br>      data-&gt;password);<br>    WRBClientWrite(WRBCtx, wbuf, len);<br> <br>    /* confirm password */<br>    len = sprintf(wbuf,<br>      " Confirm Password: &lt;INPUT TYPE=\"password\" NAME=\"confirm\" ");<br>    WRBClientWrite(WRBCtx, wbuf, len);<br> <br>    len = sprintf(wbuf, "VALUE=\"%s\" MAXLENGTH=\"10\" SIZE=\"10\"&gt;&lt;/P&gt;\n",<br>      data-&gt;password);<br>    WRBClientWrite(WRBCtx, wbuf, len);<br> <br>#ifdef DEBUG<br>    WRBLogMessage(WRBCtx, "formatUserData: opening infofile", 0);<br>#endif<br> <br>    /* open infofile and write its data to the client */<br>    ohome = WRBGetORACLE_HOME(WRBCtx);<br>    sprintf(infofile, "%s/ows21/sample/wrbsdk/mywrbapp/%s.info", ohome, data-&gt;username);<br>    info = fopen(infofile, "r");<br> <br>    /* fullname */<br>    fgets(buf, 1024, info);<br>    bp = strchr(buf, `:');<br>    bp += 2;<br>    ep = strchr(bp, `\n');<br>    *ep = `\0';<br> <br>    len = sprintf(wbuf,<br>      "&lt;P&gt;Full Name: &lt;INPUT TYPE=\"text\" NAME=\"fullname\" ");<br>    WRBClientWrite(WRBCtx, wbuf, len);<br> <br>    len = sprintf(wbuf, "VALUE=\"%s\"&gt;&lt;/P&gt;\n", bp);<br>    WRBClientWrite(WRBCtx, wbuf, len);<br> <br>    /* address */<br>    fgets(buf, 1024, info);<br>    bp = strchr(buf, `:');<br>    bp += 2;<br>    ep = strchr(bp, `\n');<br>    *ep = `\0';<br> <br>    len = sprintf(wbuf,<br>      "&lt;P&gt;Street Address: &lt;INPUT TYPE=\"text\" NAME=\"address\" ");<br>    WRBClientWrite(WRBCtx, wbuf, len);<br> <br>    len = sprintf(wbuf, "VALUE=\"%s\"&gt;&lt;/P&gt;\n", bp);<br>    WRBClientWrite(WRBCtx, wbuf, len);<br> <br>    /* city */<br>    fgets(buf, 1024, info);<br>    bp = strchr(buf, `:');<br>    bp += 2;<br>    ep = strchr(bp, `\n');<br>    *ep = `\0';<br> <br>    len = sprintf(wbuf,<br>      "&lt;P&gt;City: &lt;INPUT TYPE=\"text\" NAME=\"city\" ");<br>    WRBClientWrite(WRBCtx, wbuf, len);<br> <br>    len = sprintf(wbuf, "VALUE=\"%s\"&gt;&lt;/P&gt;\n", bp);<br>    WRBClientWrite(WRBCtx, wbuf, len);<br> <br>    /* state */<br>    fgets(buf, 1024, info);<br>    bp = strchr(buf, `:');<br>    bp += 2;<br>    ep = strchr(bp, `\n');<br>    *ep = `\0';<br> <br>    len = sprintf(wbuf,<br>      "&lt;P&gt;State: &lt;INPUT TYPE=\"text\" NAME=\"state\" ");<br>    WRBClientWrite(WRBCtx, wbuf, len);<br> <br>    len = sprintf(wbuf, "VALUE=\"%s\" MAXLENGTH=\"2\" SIZE=\"2\"&gt;&lt;/P&gt;\n", bp);<br>    WRBClientWrite(WRBCtx, wbuf, len);<br> <br>    /* zip */<br>    fgets(buf, 1024, info);<br>    bp = strchr(buf, `:');<br>    bp += 2;<br>    ep = strchr(bp, `\n');<br>    *ep = `\0';<br> <br>    len = sprintf(wbuf,<br>      "&lt;P&gt;Zip: &lt;INPUT TYPE=\"text\" NAME=\"zip\" ");<br>    WRBClientWrite(WRBCtx, wbuf, len);<br> <br>    len = sprintf(wbuf, "VALUE=\"%s\"&gt;&lt;/P&gt;\n", bp);<br>    WRBClientWrite(WRBCtx, wbuf, len);<br> <br>    /* country */<br>    fgets(buf, 1024, info);<br>    bp = strchr(buf, `:');<br>    bp += 2;<br>    ep = strchr(bp, `\n');<br>    *ep = `\0';<br> <br>    len = sprintf(wbuf,<br>      "&lt;P&gt;Country: &lt;INPUT TYPE=\"text\" NAME=\"country\" ");<br>    WRBClientWrite(WRBCtx, wbuf, len);<br> <br>    len = sprintf(wbuf, "VALUE=\"%s\"&gt;&lt;/P&gt;\n", bp);<br>    WRBClientWrite(WRBCtx, wbuf, len);<br> <br>    /* email */<br>    fgets(buf, 1024, info);<br>    bp = strchr(buf, `:');<br>    bp += 2;<br>    ep = strchr(bp, `\n');<br>    *ep = `\0';<br> <br>    len = sprintf(wbuf,<br>      "&lt;P&gt;Email Address: &lt;INPUT TYPE=\"text\" NAME=\"email\" ");<br>    WRBClientWrite(WRBCtx, wbuf, len);<br> <br>    len = sprintf(wbuf, " SIZE=\"40\" VALUE=\"%s\"&gt;&lt;/P&gt;\n", bp);<br>    WRBClientWrite(WRBCtx, wbuf, len);<br> <br>    len = sprintf(wbuf, "&lt;INPUT TYPE=\"submit\" NAME=\"submit\" ");<br>    WRBClientWrite(WRBCtx, wbuf, len);<br> <br>    len = sprintf(wbuf, "VALUE=\"Save Changes\"&gt;\n&lt;/FORM&gt;\n");<br>    WRBClientWrite(WRBCtx, wbuf, len);<br> <br>    len = sprintf(wbuf,<br>      "&lt;P&gt;&lt;A HREF=\"/mywrbapp/bin/getcatalog\"&gt;Go to the catalog&lt;/A&gt;&lt;/P&gt;\n");<br>    WRBClientWrite(WRBCtx, wbuf, len);<br> <br>    len = sprintf(wbuf, "&lt;/BODY&gt;\n&lt;/HTML&gt;\n");<br>    WRBClientWrite(WRBCtx, wbuf, len);<br> <br>#ifdef DEBUG<br>    WRBLogMessage(WRBCtx, "formatUserData: finished client writes", 0);<br>#endif<br> <br>    fclose(info);<br> <br>    return (WRB_DONE);<br>}<br></PRE><P>
</A>
<HR>
<H2>
<A NAME="422460">
userDataError()
</A>
</H2>
<A NAME="422467">
<code><a href="mywrbap3.htm#422380">newUser()</a></code> and <code><a href="mywrbap3.htm#422393">editUserData()</a></code> calls <code>userDataError()</code> to generate an HTML error page using the text specified by <code>message</code>. The <code>URL</code> parameter specifies the registration form to which to provide a link.<P>
</A><A NAME="422468">
<PRE>void<br>userDataError(const char *message, const char *URL, myappctx* ctx, void *WRBCtx)<br>{<br>    char wbuf[1024];<br>    int len;<br> <br>    WRBClientWrite(WRBCtx, "Content-type: text/html\n\n", 25);<br> <br>    len = sprintf(wbuf, "&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;Error&lt;/TITLE&gt;&lt;/HEAD&gt;\n");<br>    WRBClientWrite(WRBCtx, wbuf, len);<br> <br>    len = sprintf(wbuf, "&lt;BODY BGCOLOR=\"FFFFFF\"&gt;\n&lt;H1&gt;Error&lt;/H1&gt;\n");<br>    WRBClientWrite(WRBCtx, wbuf, len);<br> <br>    len = sprintf(wbuf, "&lt;P&gt;%s&lt;/P&gt;\n", message);<br>    WRBClientWrite(WRBCtx, wbuf, len);<br> <br>    len = sprintf(wbuf,<br>      "&lt;P&gt;&lt;A HREF=\"%s\"&gt;Return ", URL);<br>    WRBClientWrite(WRBCtx, wbuf, len);<br> <br>    len = sprintf(wbuf, "to the registration form&lt;/A&gt;.&lt;/P&gt;\n");<br>    WRBClientWrite(WRBCtx, wbuf, len);<br> <br>    len = sprintf(wbuf, "&lt;/BODY&gt;\n&lt;/HTML&gt;\n");<br>    WRBClientWrite(WRBCtx, wbuf, len);<br> <br>    return;<br>}<br></PRE><P>
</A>
<HR>
<H2>
<A NAME="422469">
storeInfo()
</A>
</H2>
<A NAME="422476">
<code><a href="mywrbap3.htm#422380">newUser()</a></code> and <code><a href="mywrbap3.htm#422393">editUserData()</a></code> call <code>storeInfo()</code> to parse all registration form data for a user (except username and password, which are hashed in the data file) and store it in an ASCII file on the host file system.<P>
</A><A NAME="422477">
<PRE>WRBReturnCode<br>storeInfo(const char *user, myappctx *ctx, void *WRBCtx)<br>{<br>    int fd;<br>    char buf[256];<br>    char *cp;<br>    WRBEntry *entries;<br>    int numentries;<br>    char infofile[256];<br>    char *ohome;<br> <br>    /* create infofile for this user */<br>    ohome = WRBGetORACLE_HOME(WRBCtx);<br>    sprintf(infofile, "%s/ows21/sample/wrbsdk/mywrbapp/%s.info", ohome, user);<br>    fd = open(infofile, O_CREAT | O_TRUNC | O_RDWR, 0664);<br>    if (fd == -1) {<br>        return (WRB_ABORT);<br>    }<br> <br>    /* get form data */<br>    WRBGetParsedContent(WRBCtx, &amp;entries, &amp;numentries);<br> <br>    cp = WRBGetNamedEntry("fullname", entries, numentries);<br>    sprintf(buf, "Full Name: %s\n", cp);<br>    write(fd, buf, strlen(buf));<br> <br>    cp = WRBGetNamedEntry("address", entries, numentries);<br>    sprintf(buf, "Street Address: %s\n", cp);<br>    write(fd, buf, strlen(buf));<br> <br>    cp = WRBGetNamedEntry("city", entries, numentries);<br>    sprintf(buf, "City: %s\n", cp);<br>    write(fd, buf, strlen(buf));<br> <br>    cp = WRBGetNamedEntry("state", entries, numentries);<br>    sprintf(buf, "State: %s\n", cp);<br>    write(fd, buf, strlen(buf));<br> <br>    cp = WRBGetNamedEntry("zip", entries, numentries);<br>    sprintf(buf, "Zip Code: %s\n", cp);<br>    write(fd, buf, strlen(buf));<br> <br>    cp = WRBGetNamedEntry("country", entries, numentries);<br>    sprintf(buf, "Country: %s\n", cp);<br>    write(fd, buf, strlen(buf));<br> <br>    cp = WRBGetNamedEntry("email", entries, numentries);<br>    sprintf(buf, "Email Address: %s\n", cp);<br>    write(fd, buf, strlen(buf));<br> <br>    close(fd);<br>    return (WRB_DONE);<br>}<br></PRE><P>
</A>
<HR>
<H2>
<A NAME="422482">
getDataBlock()
</A>
</H2>
<A NAME="422483">
<code>getDataBlock()</code> retrieves the data block for the specified user from the data file and returns it to the caller.<P>
</A><A NAME="422484">
<PRE>datablock *<br>getDataBlock(const char *user, myappctx *ctx, void *WRBCtx)<br>{<br> <br>    unsigned hashval;<br>    char *cp;<br>    datablock *data = NULL;<br>    off_t size;<br> <br>    RDLOCK(FILE_START, FILE_SIZE, ctx)<br> <br>    /*<br>     * check to see if another WRBX has extended the datafile--<br>     * if so, remap the file<br>     */<br>    size = lseek(ctx-&gt;datafd, 0, SEEK_END);<br>    if (size &gt; ctx-&gt;end) {<br>        /* file has grown--remap it */<br> <br>        UNLOCK(ctx)<br> <br>        if (remapdata(ctx, WRBCtx) != WRB_DONE) {<br>            return (NULL);<br>        }<br> <br>        RDLOCK(FILE_START, FILE_SIZE, ctx)<br>    }<br> <br>    /* hash on username--retrieve datablock from hash table */<br>    cp = strdup(user);<br>    THASH(hashval, cp)<br>    data = ctx-&gt;datablocks + ctx-&gt;table[hashval];<br>    while (data != ctx-&gt;datablocks) {<br>        /*<br>         * end of list not yet reached--compare datablock username<br>         * with given value--break out if match<br>         */<br>        if (!strcmp(user, data-&gt;username)) {<br>            break;<br>        }<br> <br>        data = ctx-&gt;datablocks + data-&gt;nextidx;<br>    }<br> <br>    UNLOCK(ctx)<br> <br>    if (data == ctx-&gt;datablocks) {<br>        /* end of hash list reached--no datablock found for given username */<br>        return (NULL);<br>    }<br> <br>#ifdef DEBUG<br>    sprintf(debug, "getDataBlock: data block found for user %s",<br>      data-&gt;username);<br>    WRBLogMessage(WRBCtx, debug, 1);<br>#endif<br> <br>    return (data);<br>}<br></PRE><P>
</A>
<HR>
<H2>
<A NAME="422486">
formatOrder()
</A>
</H2>
<A NAME="422493">
<code><a href="mywrbap3.htm#422413">placeOrder()</a></code> and <code><a href="mywrbap3.htm#422424">confirmOrder()</a></code>call <code>formatOrder()</code> to format the client order encapsulated in the <code>ctx</code> structure in HTML format and send it to the client. <P>
</A><A NAME="422494">
If invoice is <code>TRUE</code>, formatOrder() outputs a non-editable HTML page and prints price totals. Otherwise, it outputs an editable HTML form with <code>&lt;INPUT&gt;</code> fields. <em>formatOrder()</em> does <em>not</em> output a Content-type header, an HTML header, or an HTML trailer; the caller is responsible for outputting that information.<P>
</A><A NAME="422495">
<PRE>WRBReturnCode<br>formatOrder(const boolean invoice, myappctx *ctx, void *WRBCtx)<br>{<br>    FILE *cat;<br>    char lbuf[1024];<br>    char *lp;<br>    char wbuf[1024];<br>    int len;<br>    orderitem* items;<br>    int item = 0;<br>    double itemprice;<br>    double quantity;<br>    double total = 0;<br>    char catfile[256];<br>    char *ohome;<br> <br>    /* open catalog */<br>    ohome = WRBGetORACLE_HOME(WRBCtx);<br>    sprintf(catfile, "%s/ows21/sample/wrbsdk/mywrbapp/catalog.txt", ohome);<br>    cat = fopen(catfile, "r");<br>    if (!cat) {<br>#ifdef DEBUG<br>        WRBLogMessage(WRBCtx, "formatOrder: failed to open catalog", 0);<br>#endif<br>        return (WRB_ABORT);<br>    }<br> <br>    /*<br>     * because both the items array and the catalog file are sorted by<br>     * part number, loop through without seeking backward<br>     */<br>    items = ctx-&gt;items;<br>    while ((item &lt; ctx-&gt;numitems)) {<br>        if ((items[item].qty[0] == `\0') || (items[item].qty[0] == `0')) {<br>            /* skip empty quantities */<br>            item++;<br>            continue;<br>        }<br> <br>        /* skip description line, get part number line */<br>        fgets(lbuf, 1024, cat);<br>        if (!fgets(lbuf, 1024, cat)) {<br>            break;<br>        }<br>        if (!strncmp(lbuf, items[item].partnum, PARTNUMLEN)) {<br>            /*<br>             * found the catalog entry for current item--<br>             * write it out to the client<br>             */<br>            WRBClientWrite(WRBCtx, "&lt;P&gt;", 3);<br>            WRBClientWrite(WRBCtx, lbuf, strlen(lbuf));<br> <br>            if (invoice) {<br>                /* calculate and print price, add to subtotal */<br>                lp = strchr(lbuf, `$');<br>                lp++;<br>                itemprice = atof(lp);<br>                quantity = atof(items[item].qty);<br>                len = sprintf(wbuf, " Quantity: %s @ $%.2f = $%.2f&lt;/P&gt;\n",<br>                  items[item].qty, itemprice, itemprice * quantity);<br>                WRBClientWrite(WRBCtx, wbuf, len);<br> <br>                total += itemprice * quantity;<br>            }<br>            else {<br>                /*<br>                 * not an invoice--write quantity out as an editable<br>                 * input field<br>                 */<br>                len = sprintf(wbuf, " Order quantity: &lt;INPUT TYPE=\"text\" ");<br>                WRBClientWrite(WRBCtx, wbuf, len);<br> <br>                len = sprintf(wbuf, "NAME=\"%s\" ", items[item].partnum);<br>                WRBClientWrite(WRBCtx, wbuf, len);<br> <br>                len = sprintf(wbuf,<br>                  "SIZE=\"4\" VALUE=\"%s\"&gt;&lt;/P&gt;\n", items[item].qty);<br>                WRBClientWrite(WRBCtx, wbuf, len);<br>            }<br>            item++;<br>        }<br>    }<br> <br>    if (invoice) {<br>        if (taxable(WRBGetUserID(WRBCtx), ctx, WRBCtx)) {<br>            /* print subtotal */<br>            len = sprintf(wbuf, "&lt;P&gt;Subtotal: $%.2f&lt;/P&gt;\n", total);<br>            WRBClientWrite(WRBCtx, wbuf, len);<br> <br>            /* calc and print tax */<br>            len = sprintf(wbuf, "&lt;P&gt;Tax @ %.2f%%: $%.2f&lt;/P&gt;\n",<br>              ctx-&gt;taxpct, (ctx-&gt;taxpct/100)*total);<br>            WRBClientWrite(WRBCtx, wbuf, len);<br> <br>            /* print total with tax */<br>            len = sprintf(wbuf, "&lt;P&gt;Your total is: $%.2f&lt;/P&gt;\n",<br>              total + (ctx-&gt;taxpct/100)*total);<br>            WRBClientWrite(WRBCtx, wbuf, len);<br>        }<br>        else {<br>            /* print total (no tax) */<br>            len = sprintf(wbuf, "&lt;P&gt;Your total is: $%.2f&lt;/P&gt;\n", total);<br>            WRBClientWrite(WRBCtx, wbuf, len);<br>        }<br>    }<br> <br>    fclose(cat);<br> <br>    return (WRB_DONE);<br>}<br></PRE><P>
</A>
<HR>
<H2>
<A NAME="422496">
taxable()
</A>
</H2>
<A NAME="422497">
<code>taxable()</code> uses the client's registration data and the cartridge configuration parameters to determine whether the client lives in our home state, and hence should be charged sales tax.<P>
</A><A NAME="422498">
<PRE>boolean<br>taxable(char *user, myappctx *ctx, void *WRBCtx)<br>{<br>    FILE *info;<br>    char *ohome;<br>    char buf[1024];<br>    char *cp = NULL;<br> <br>#ifdef DEBUG<br>    WRBLogMessage(WRBCtx, "taxable: entering", 0);<br>#endif<br>    /* open user's info file */<br>    ohome = WRBGetORACLE_HOME(WRBCtx);<br>    sprintf(buf, "%s/ows21/sample/wrbsdk/mywrbapp/%s.info", ohome, user);<br>    info = fopen(buf, "r");<br> <br>    /* get user's home state */<br>    while (fgets(buf, 1024, info)) {<br>        if (!strncmp(buf, "State:", 6)) {<br>            cp = strchr(buf, `:');<br>            cp += 2;<br>            break;<br>        }<br>    }<br> <br>    /* compare it with our home state */<br>    if (cp &amp;&amp; ctx-&gt;state &amp;&amp; !strncmp(cp, ctx-&gt;state, 2)) {<br>        /* they're in our state--tax `em */<br>#ifdef DEBUG<br>        WRBLogMessage(WRBCtx, "taxable: returning TRUE", 0);<br>#endif<br>        return (TRUE);<br>    }<br> <br>#ifdef DEBUG<br>        WRBLogMessage(WRBCtx, "taxable: returning FALSE", 0);<br>#endif<br>    return (FALSE);<br>}<br></PRE><P>
</A>
<HR>
<H2>
<A NAME="422499">
itemcmp()
</A>
</H2>
<A NAME="422503">
<code><a href="mywrbap3.htm#422413">placeOrder()</a></code> passes a pointer to <code>itemcmp()</code> to the <code>qsort</code>(3) library function to use in sorting the <code>orderitems</code> array that encapsulates a client's order.<P>
</A><A NAME="422504">
<PRE>int<br>itemcmp(const void* item1, const void* item2)<br>{<br>    return(strcmp(((orderitem *)item1)-&gt;partnum,<br>      ((orderitem *)item2)-&gt;partnum));<br>}<br></PRE><P>
</A>
<HR>
<H2>
<A NAME="422506">
mapdata()
</A>
</H2>
<A NAME="422513">
<code><a href="mywrbap3.htm#422338">MyWRBApp_Init()</a></code> and <code><a href="mywrbap3.htm#422516">remapdata()</a></code> call <code>mapdata()</code> to map into memory the data file specified by <code>fd</code>, and if <code>ctx</code> is <code>NULL</code>, to allocate an application context structure for the calling WRBX.<P>
</A><A NAME="422514">
<PRE>myappctx *<br>mapdata(const int fd, myappctx *ctx, void *WRBCtx)<br>{<br>    off_t size;<br> <br>    if (!ctx) {<br>        /* NULL context means allocate context */<br>        if (!(ctx = (myappctx *)malloc(sizeof(myappctx)))) {<br>#ifdef DEBUG<br>            WRBLogMessage(WRBCtx, "mapdata: context malloc failed", 0);<br>#endif<br>            return (NULL);<br>        }<br>    }<br> <br>    RDLOCK(FILE_START, FILE_SIZE, ctx)<br> <br>    /* fd refers to the open datafile--find its size */<br>    size = lseek(fd, 0, SEEK_END);<br>#ifdef DEBUG<br>    sprintf(debug, "mapdata: datafile size is %u", size);<br>    WRBLogMessage(WRBCtx, debug, 1);<br>#endif<br> <br>    if (size &lt; MINFILESIZE) {<br>        /* data file too small--it was probably just created */<br> <br>        UPGRADE(ctx)<br> <br>        /* extend file */<br>        size = lseek(fd, MINFILESIZE - 1, SEEK_END);<br>        if (write(fd, "\0", 1) != 1) {<br>#ifdef DEBUG<br>            sprintf(debug, "mapdata: failed to extend file:");<br>            WRBLogMessage(WRBCtx, debug, 1);<br>            sprintf(debug, "\t%s", strerror(errno));<br>            WRBLogMessage(WRBCtx, debug, 1);<br>#endif<br>            goto error;<br>        }<br> <br>        size = lseek(fd, 0, SEEK_END);<br>#ifdef DEBUG<br>        sprintf(debug, "mapdata: extended datafile to size: %u", size);<br>        WRBLogMessage(WRBCtx, debug, 1);<br>#endif<br> <br>        DOWNGRADE(ctx)<br>    }<br> <br>    /* map entire file into memory */<br>    ctx-&gt;table = (int *)mmap(NULL, size, PROT_READ | PROT_WRITE,<br>      MAP_SHARED, fd, (off_t)0);<br>    if (ctx-&gt;table == MAP_FAILED) {<br>#ifdef DEBUG<br>        sprintf(debug, "mapdata: failed to mmap datafile:");<br>        WRBLogMessage(WRBCtx, debug, 1);<br>        sprintf(debug, "%s", strerror(errno));<br>        WRBLogMessage(WRBCtx, debug, 1);<br>#endif<br>        goto error;<br>    }<br> <br>    /* set up rest of context--defines data file format */<br>    ctx-&gt;firstfree = (int *)(ctx-&gt;table + TSIZE);<br>    ctx-&gt;datacount = (int *)(ctx-&gt;firstfree + 1);<br>    ctx-&gt;datablocks = (datablock *)(ctx-&gt;datacount + 1);<br>    ctx-&gt;datafd = fd;<br>    ctx-&gt;end = size;<br> <br>    UNLOCK(ctx)<br> <br>    return (ctx);<br> <br>error:<br>    UNLOCK(ctx)<br> <br>    return (NULL);<br>}<br></PRE><P>
</A>
<HR>
<H2>
<A NAME="422516">
remapdata()
</A>
</H2>
<A NAME="422523">
<code><a href="mywrbap3.htm#422526">growdata()</a></code> and <code><a href="mywrbap3.htm#422445">rehash()</a></code> call <code>remapdata()</code> to unmap the data file and remap it into memory. This is necessary when the datafile grows to make room for more data blocks.<P>
</A><A NAME="422524">
<PRE>WRBReturnCode<br>remapdata(myappctx *ctx, void *WRBCtx)<br>{<br> <br>    /* unmap data file */<br>    if (munmap((char *)ctx-&gt;table, ctx-&gt;end) == -1) {<br>        return (WRB_ABORT);<br>    }<br> <br>    /* remap data file */<br>    if (!mapdata(ctx-&gt;datafd, ctx, WRBCtx)) {<br>        return (WRB_ABORT);<br>    }<br> <br>    return (WRB_DONE);<br>}<br></PRE><P>
</A>
<HR>
<H2>
<A NAME="422526">
growdata()
</A>
</H2>
<A NAME="422530">
<code><a href="mywrbap3.htm#422438">addUser()</a></code> calls growdata() to extend the data file when the data file is full. It calls <code><a href="mywrbap3.htm#422516">remapdata()</a></code> to unmap and remap the data file into memory.<P>
</A><A NAME="422534">
<PRE>WRBReturnCode<br>growdata(myappctx *ctx, void *WRBCtx)<br>{<br>    off_t size;<br> <br>    WRLOCK(FILE_START, FILE_SIZE, ctx)<br> <br>    /* extend file by seeking past the end and writing a byte */<br>    size = lseek(ctx-&gt;datafd, MINFILESIZE + 1, SEEK_END);<br>#ifdef DEBUG<br>    sprintf(debug, "growdata: extended datafile to size: %u", size);<br>    WRBLogMessage(WRBCtx, debug, 1);<br>#endif<br>    if (write(ctx-&gt;datafd, "\0", 1) != 1) {<br>#ifdef DEBUG<br>        sprintf(debug, "growdata: failed to extend datafile: %s",<br>          strerror(errno));<br>        WRBLogMessage(WRBCtx, debug, 1);<br>#endif<br>        goto error;<br>    }<br> <br>    /* sync datafile */<br>    if (msync((char *)ctx-&gt;table, ctx-&gt;end, MS_SYNC | MS_INVALIDATE) == -1) {<br>#ifdef DEBUG<br>        sprintf(debug, "growdata: failed to msync datafile: %s",<br>          strerror(errno));<br>        WRBLogMessage(WRBCtx, debug, 1);<br>#endif<br>        goto error;<br>    }<br> <br>    UNLOCK(ctx)<br> <br>    /* remap datafile */<br>    if (remapdata(ctx, WRBCtx) != WRB_DONE) {<br>        return (WRB_ABORT);<br>    }<br> <br>    return (WRB_DONE);<br> <br>error:<br>    UNLOCK(ctx)<br> <br>    return(WRB_ABORT);<br>}<br></PRE><P>
</A>
<A NAME="422535">
<P>
</A> <P>
 
<HR>
<A HREF="mywrbapp.htm"><IMG SRC="up.jpg" ALIGN=MIDDLE ALT="Click Here to"> Go to the top of the section</A><P>
<A HREF="mywrbap2.htm"><IMG SRC="previous.jpg" ALIGN=MIDDLE ALT="Click Here to "> Go to the previous topic</A><P>
<A HREF="contents.htm"><IMG SRC="toc.jpg" ALIGN=MIDDLE ALT="Click Here to "> Go to the Roadmap</A><P>
<A HREF="owshtmli.htm"><IMG SRC="index.jpg" ALIGN=MIDDLE ALT="Click Here to "> Go to the index</A><P>
<HR>
<ADDRESS>
To report any problems or comments, email <A HREF="mailto:owsdoc@us.oracle.com">Oracle WebServer Documentation</A>.<P>
</ADDRESS>
 
</BODY>
</HTML>
